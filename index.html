<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Super Invader</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Make the canvas fill the entire screen */
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Press Start 2P", cursive;
        color: white;
      }
      canvas {
        display: none; /* Hidden until game starts */
      }

      #asset-cache {
        position: absolute;
        top: -9999px;
        left: -9999px;
        width: 1px;
        height: 1px;
        overflow: hidden;
      }

      /* CRT Overlay: Keep the scanline effect but reduce overall visual noise */
      #crt-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
      }
      #crt-overlay::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.2) 0px,
          /* Reduced scanline density */ rgba(0, 0, 0, 0.2) 1px,
          transparent 1px,
          transparent 2px
        );
        opacity: 0.7;
      }
      #crt-overlay::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse at center,
          rgba(0, 0, 0, 0) 50%,
          rgba(0, 0, 0, 0.7) 100%
        );
        animation: flicker 0.1s infinite;
      }
      @keyframes flicker {
        0% {
          opacity: 0.9;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 1;
        }
      }

      /* UPDATED: Scrolling background animation for the new image */
      @keyframes scroll-background {
        from {
          background-position: 0% 0;
        }
        to {
          background-position: 100% 0; /* Scrolls from left to right */
        }
      }

      /* Game Screen Styling - Atmospheric Background */
      .game-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent;
        /* NEW: Set new background image and enable scrolling */
        background-image: url("https://images6.alphacoders.com/885/885542.png");
        background-size: auto 100%; /* Cover height, let width scroll */
        background-position: 0% 0;
        background-attachment: fixed;
        animation: scroll-background 60s linear infinite; /* Apply scrolling */
        z-index: 20;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        color: #00ffff; /* Default Cyan text for menu elements */
        /* Subtle haze effect over background */
        background-blend-mode: overlay;
        background-color: rgba(0, 0, 0, 0.6);
      }

      /* Title H1 - Focused on Neon Glow & Clarity */
      .game-screen h1,
      .game-screen h2 {
        text-shadow: 2px 2px #000;
        margin-bottom: 20px;
      }
      .game-screen h1 {
        font-size: 3.5em;
        /* Rainbow text remains */
        background: linear-gradient(
          90deg,
          #ff4444,
          /* Brighter Red */ #ffdd44,
          /* Brighter Yellow */ #44ff44,
          /* Brighter Green */ #44ffff,
          /* Cyan */ #4444ff /* Blue */
        );
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow-text-animation 5s linear infinite;

        /* UPDATED: Multi-layered text-shadow for "Glowy Minerals" effect */
        text-shadow: 1px 1px 0 #000, 0 0 5px #00ffff,
          /* Base Cyan Glow (Clearer) */ 0 0 10px #ff00ff,
          /* Pink/Magenta secondary glow (Minerals) */ 0 0 20px
            rgba(0, 255, 255, 0.8); /* Strong outer halo */
      }
      @keyframes rainbow-text-animation {
        0% {
          background-position: 0% 50%;
        }
        100% {
          background-position: 100% 50%;
        }
      }

      .game-screen h2 {
        font-size: 2em;
        color: #33ff33; /* Cyber Green for headings */
        text-shadow: 0 0 8px #33ff33;
      }

      /* Instructions Styling */
      #main-menu-screen p.instructions {
        font-size: 0.8em;
        margin-top: 20px;
        margin-bottom: 40px;
        color: #00ffff; /* Cyan Text */
        text-shadow: none;
        padding: 15px;
        /* Softer border blending into the background */
        border: 1px solid rgba(0, 255, 255, 0.4);
        max-width: 90%;
        line-height: 1.5;
        background-color: rgba(0, 0, 0, 0.5); /* Subtle dark container */
        box-shadow: inset 0 0 5px rgba(0, 255, 255, 0.2);
      }

      /* Buttons - Modern Indie Neon Style */
      .menu-button {
        font-family: "Press Start 2P", cursive;
        font-size: 1.3em;
        padding: 12px 24px;
        background-color: rgba(0, 0, 0, 0.4); /* Slightly visible background */
        color: #33ff33; /* Default Cyber Green Text */
        border: 1px solid #33ff33; /* Subtle Green Border */
        cursor: pointer;
        margin: 10px;
        text-shadow: none;
        transition: all 0.15s ease-in-out;
        box-shadow: 0 0 5px rgba(51, 255, 51, 0.5);
      }
      .menu-button:hover {
        background-color: rgba(0, 255, 255, 0.1); /* Cyan fill on hover */
        color: #00ffff; /* Cyan text on hover */
        border-color: #00ffff;
        /* Stronger neon glow on hover */
        box-shadow: 0 0 15px #00ffff, 0 0 25px rgba(0, 255, 255, 0.8);
      }
      .menu-button:disabled {
        background-color: rgba(0, 0, 0, 0.4);
        color: #555;
        border-color: #555;
        cursor: not-allowed;
        box-shadow: none;
      }

      #ship-select-container {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }

      /* Ship Card Styling adjustments */
      .ship-card {
        border: 2px solid #00ffff;
        padding: 15px;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        background: rgba(0, 0, 0, 0.7);
        color: #33ff33; /* Ship text in green */
      }
      .ship-card:hover {
        border-color: #33ff33;
        box-shadow: 0 0 10px #33ff33;
        transform: scale(1.05);
        background: rgba(0, 0, 0, 0.85);
      }
      .ship-card img {
        width: 96px;
        height: 96px;
        image-rendering: pixelated;
      }
      .ship-card p {
        margin: 5px 0 0 0;
        font-size: 0.8em;
      }
      .ship-card.locked {
        cursor: not-allowed;
        filter: grayscale(1) brightness(0.5);
      }
      .ship-card.locked:hover {
        border-color: #888;
        box-shadow: none;
        transform: none;
      }

      .modal {
        display: none;
        position: absolute;
        z-index: 25;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.8);
        color: #00ffff; /* Modal default color: Cyan */
        align-items: center;
        justify-content: center;
      }
      .modal-content {
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ffff;
        padding: 20px;
        width: 90%;
        max-width: 600px;
        text-align: center;
        box-shadow: 0 0 10px #00ffff;
      }
      .modal-content h2 {
        color: #33ff33;
        text-shadow: 0 0 5px #33ff33;
      }
      .modal-content input {
        font-family: "Press Start 2P", cursive;
        background: #000;
        border: 1px solid #33ff33;
        color: #00ffff; /* Input text in Cyan */
        padding: 10px;
        font-size: 1em;
        margin: 10px 0;
        width: 80%;
      }

      #leaderboard-list {
        list-style: none;
        padding: 0;
        max-height: 50vh;
        overflow-y: auto;
        text-align: left;
      }
      #leaderboard-list li {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        border-bottom: 1px solid rgba(0, 255, 255, 0.3); /* Subtle divider */
      }
      #leaderboard-list li span:first-child {
        margin-right: 20px;
      }

      #discovery-panel {
        display: none;
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        max-width: 800px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.85);
        border: 2px solid #00ffff;
        color: #fff;
        text-align: center;
        z-index: 15;
        box-shadow: 0 0 15px #00ffff;
      }
      #discovery-panel h2 {
        margin-top: 0;
        font-size: 1.2em;
      }
      #discovery-panel p {
        margin: 8px 0;
        font-size: 0.8em;
        line-height: 1.4;
      }
      #discovery-close-prompt {
        margin-top: 10px;
        font-size: 0.7em;
        color: #aaa;
      }
      .rarity-Common {
        color: #ffffff;
      }
      .rarity-Rare {
        color: #55aaff;
        text-shadow: 0 0 5px #55aaff;
      }
      .rarity-Legendary {
        color: #ffd700;
        text-shadow: 0 0 8px #ffd700;
      }
      .rarity-Unique {
        background: linear-gradient(
          90deg,
          #ff0000,
          #ff7f00,
          #ffff00,
          #00ff00,
          #0000ff,
          #4b0082,
          #9400d3
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow-text 3s linear infinite;
      }
      @keyframes rainbow-text {
        0% {
          background-position: 0% 50%;
        }
        100% {
          background-position: 100% 50%;
        }
      }

      #pirate-warning {
        display: none;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2em;
        color: #ff0000;
        text-shadow: 3px 3px #000;
        z-index: 16;
        animation: pulse-warning 1s infinite;
      }
      @keyframes pulse-warning {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      #steal-progress-bar-container {
        display: none;
        position: absolute;
        top: 120px;
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        height: 20px;
        border: 2px solid #ff0000;
        background: #330000;
        z-index: 16;
      }
      #steal-progress-bar {
        width: 0%;
        height: 100%;
        background: #ff0000;
      }

      /* NEW: Invasion Timer */
      #invasion-timer {
        display: none;
        position: absolute;
        top: 75px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.5em;
        color: #ff0000;
        text-shadow: 2px 2px #000;
        z-index: 16;
      }

      /* NEW: Rank Notification Panel */
      #rank-notification-panel {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 400px;
        padding: 20px;
        background: rgba(0, 0, 0, 0.9);
        border: 4px solid #33ff33;
        box-shadow: 0 0 20px #33ff33;
        text-align: center;
        z-index: 50;
      }
      #rank-notification-panel h2 {
        color: #00ffff;
      }
      #rank-notification-panel p {
        font-size: 1em;
        margin: 10px 0;
      }

      /* NEW: Intro Message Panel Styling */
      #intro-message-panel {
        display: none;
        position: absolute;
        top: 30%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 600px;
        padding: 25px;
        background: rgba(0, 0, 0, 0.95);
        /* UPDATED: Border and shadow changed to Cyan */
        border: 4px solid #00ffff;
        box-shadow: 0 0 25px #00ffff, inset 0 0 10px #00ffff;
        color: #00ffff;
        text-align: center;
        z-index: 100; /* Highest z-index */
      }
      #intro-message-panel p {
        font-size: 1em;
        margin: 0;
        line-height: 1.5;
      }

      #touch-controls {
        display: none;
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 12;
        pointer-events: none;
      }
      .touch-button {
        position: absolute;
        bottom: 50px; /* Increased base height */
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.4);
        pointer-events: auto;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 12px;
        user-select: none;
      }
      .touch-button.active {
        background: rgba(255, 255, 255, 0.5);
      }
      #joystick-base {
        position: absolute;
        left: 40px;
        bottom: 40px;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.4);
        pointer-events: auto;
      }
      #joystick-knob {
        position: absolute;
        left: 30px;
        top: 30px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.4);
      }

      /* New positions for the buttons to increase spacing */
      #shoot-button {
        right: 40px;
        bottom: 90px; /* Moved up for better separation from joystick */
        background: rgba(255, 51, 51, 0.2);
        border-color: rgba(255, 51, 51, 0.4);
      }

      /* Dock button repositioned (since Turbo is removed) */
      #dock-button {
        display: none;
        right: 130px; /* New position for more spacing */
        bottom: 90px;
        background: rgba(0, 255, 255, 0.2);
        border-color: rgba(0, 255, 255, 0.4);
      }

      /* Turbo button element is REMOVED from HTML */

      #dock-prompt {
        display: none;
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translateX(-50%);
        color: #00ffff;
        font-size: 1.5em;
        text-shadow: 2px 2px #000;
        z-index: 13;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="crt-overlay"></div>
    <div id="asset-cache"></div>

    <div id="main-menu-screen" class="game-screen">
      <h1>Super Invader</h1>
      <p class="instructions">
        **Controls (PC/Keyboard):**<br />
        <br />
        **&larr; &rarr; Arrow Keys:** Rotate Ship<br />
        **&uarr; Arrow Key:** Thrust Forward (MAX SPEED)<br />
        **&darr; Arrow Key:** Reverse Thrust<br />
        **Spacebar:** Fire Projectile 💥<br />
        **E:** Interact (e.g., Close Panel / Dock)
      </p>
      <div>
        <button id="startButton" class="menu-button" disabled>
          Loading...
        </button>
        <button id="leaderboardButton" class="menu-button">Leaderboard</button>
      </div>
    </div>

    <div id="pilot-name-screen" class="game-screen" style="display: none">
      <h2>Identify Yourself, Pilot</h2>
      <p>Enter your name before launching your vessel.</p>
      <input
        type="text"
        id="pilotNameInput"
        placeholder="Pilot Name"
        maxlength="10"
      />
      <button id="confirmPilotNameButton" class="menu-button" disabled>
        Start Mission
      </button>
    </div>

    <div id="ship-select-screen" class="game-screen" style="display: none">
      <h2>Choose Your Ship</h2>
      <div id="ship-select-container">
        <div class="ship-card" data-ship="ship1">
          <img src="ship1.png" alt="Vanguard" />
          <p>Vanguard</p>
          <p>Life: 5/5</p>
          <p>Upgrades: 1</p>
        </div>
        <div class="ship-card" data-ship="ship2">
          <img src="ship2.png" alt="Interceptor" />
          <p>Interceptor</p>
          <p>Life: 3/3</p>
          <p>Upgrades: 2</p>
        </div>
        <div class="ship-card locked" data-ship="ship3">
          <img src="ship3.png" alt="???" />
          <p>???</p>
          <p>PREMIUM</p>
          <p>Locked</p>
        </div>
      </div>
    </div>
    <div id="game-over-screen" class="game-screen" style="display: none">
      <h1>Game Over</h1>
      <button id="restartButton" class="menu-button">Main Menu</button>
    </div>

    <div id="discovery-panel">
      <h2 id="discovery-name"></h2>
      <p id="discovery-formula"></p>
      <p id="discovery-description"></p>
      <p id="discovery-close-prompt">Press 'E' to close</p>
    </div>
    <div id="pirate-warning">INVASION!</div>
    <div id="invasion-timer"></div>
    <div id="steal-progress-bar-container">
      <div id="steal-progress-bar"></div>
    </div>
    <div id="dock-prompt">Press 'E' to Dock</div>

    <div id="rank-notification-panel">
      <h2>RANK UP!</h2>
      <p>Congratulations, Pilot!</p>
      <p>You are now a <span id="new-rank-name"></span></p>
    </div>

    <div id="intro-message-panel">
      <p>**INCOMING TRANSMISSION**</p>
      <p style="color: #ff00ff; margin-top: 15px">
        Pilot. This galaxy holds more than just minerals and pirates. There are
        coordinates waiting to be solved.
      </p>
      <p style="color: #33ff33; margin-top: 10px">
        Succeed, and perhaps our paths will cross...
      </p>
      <p style="font-size: 0.7em; color: #888; margin-top: 20px">
        (Transmission lost)
      </p>
    </div>

    <div id="leaderboard-modal" class="modal">
      <div class="modal-content">
        <h2>Leaderboard</h2>
        <ol id="leaderboard-list"></ol>
        <button id="closeLeaderboardButton" class="menu-button">Close</button>
      </div>
    </div>
    <div id="save-score-modal" class="modal">
      <div class="modal-content">
        <h2>Docked at Station</h2>
        <p>Your current score is <span id="save-score-value">0</span>.</p>
        <input
          type="text"
          id="playerNameInput"
          placeholder="Enter Your Name"
          maxlength="10"
        />
        <button id="saveScoreButton" class="menu-button">Save Score</button>
        <button id="viewLeaderboardFromStationButton" class="menu-button">
          View Leaderboard
        </button>
        <button id="undockButton" class="menu-button">Undock</button>
      </div>
    </div>

    <div id="touch-controls">
      <div id="joystick-base">
        <div id="joystick-knob"></div>
      </div>

      <div id="shoot-button" class="touch-button">FIRE</div>

      <div id="dock-button" class="touch-button">DOCK</div>
    </div>

    <script type="module">
      // --- FIREBASE IMPORTS ---
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        collection,
        addDoc,
        onSnapshot,
        query,
        where,
        orderBy,
        limit,
        setLogLevel,
        getDocs,
        updateDoc, // NEW for multiplayer state updates
        doc, // NEW for deleting player status
        deleteDoc, // NEW for deleting player status
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      // --- SETUP ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const assetCache = document.getElementById("asset-cache");

      // UI Elements
      const mainMenuScreen = document.getElementById("main-menu-screen");
      const shipSelectScreen = document.getElementById("ship-select-screen");
      const pilotNameScreen = document.getElementById("pilot-name-screen");
      const gameOverScreen = document.getElementById("game-over-screen");
      const discoveryPanel = document.getElementById("discovery-panel");
      const startButton = document.getElementById("startButton");
      const restartButton = document.getElementById("restartButton");
      const shipCards = document.querySelectorAll(".ship-card");
      const pilotNameInput = document.getElementById("pilotNameInput");
      const confirmPilotNameButton = document.getElementById(
        "confirmPilotNameButton"
      );
      const rankNotificationPanel = document.getElementById(
        "rank-notification-panel"
      );
      const newRankNameSpan = document.getElementById("new-rank-name");
      const introMessagePanel = document.getElementById("intro-message-panel");

      const pirateWarning = document.getElementById("pirate-warning");
      const invasionTimer = document.getElementById("invasion-timer");
      const stealBarContainer = document.getElementById(
        "steal-progress-bar-container"
      );
      const stealBar = document.getElementById("steal-progress-bar");
      const dockPrompt = document.getElementById("dock-prompt");
      const dockButton = document.getElementById("dock-button");
      const leaderboardModal = document.getElementById("leaderboard-modal");
      const saveScoreModal = document.getElementById("save-score-modal");
      const leaderboardButton = document.getElementById("leaderboardButton");
      const closeLeaderboardButton = document.getElementById(
        "closeLeaderboardButton"
      );
      const undockButton = document.getElementById("undockButton");
      const viewLeaderboardFromStationButton = document.getElementById(
        "viewLeaderboardFromStationButton"
      );
      const saveScoreButton = document.getElementById("saveScoreButton");
      const touchControls = document.getElementById("touch-controls");

      const shootButton = document.getElementById("shoot-button");

      // Multiplayer State
      let livePlayers = []; // Holds all opponent data
      let playerDocRef = null; // Reference to the current player's document in live_players

      // --- FIREBASE SETUP ---
      let db, auth;
      const appId =
        typeof __app_id !== "undefined" ? __app_id : "super-invader-standalone";

      async function initFirebase() {
        try {
          const firebaseConfig = {
            apiKey: "AIzaSyCFWrErGbsxkNwVMhJMyDYkpY1FO3B33Yk",
            authDomain: "superinvader-af884.firebaseapp.com",
            projectId: "superinvader-af884",
            storageBucket: "superinvader-af884.appspot.com",
            messagingSenderId: "196708489729",
            appId: "1:196708489729:web:2990c863c006cccf2e7e00",
            measurementId: "G-1VFFXP0X67",
          };

          const app = initializeApp(firebaseConfig);
          db = getFirestore(app);
          auth = getAuth(app);
          setLogLevel("debug");
          await signInAnonymously(auth);
          player.uid = auth.currentUser.uid; // Store the UID
          console.log("Firebase initialized and user signed in.", player.uid);
          setupLeaderboardListener();
          setupOpponentListener(); // NEW: Start listening for opponents

          // Clean up player status if browser closes
          window.addEventListener("beforeunload", removePlayerStatus);
        } catch (error) {
          console.error("Firebase initialization failed:", error);
        }
      }

      // --- MULTIPLAYER LOGIC ---

      const PLAYER_UPDATE_INTERVAL = 50; // Milliseconds to update player status (20 TPS)

      function getLivePlayersCollection() {
        return collection(db, `artifacts/${appId}/public/data/live_players`);
      }

      function setupOpponentListener() {
        const livePlayersCol = getLivePlayersCollection();
        const q = query(livePlayersCol);

        onSnapshot(q, (snapshot) => {
          livePlayers = [];
          snapshot.forEach((doc) => {
            const data = doc.data();
            if (doc.id !== player.uid) {
              // Exclude the local player
              livePlayers.push({ id: doc.id, ...data });
            }
          });
        });
      }

      let lastUpdateTime = 0;

      function updatePlayerStatus() {
        if (!player.uid || gameState !== "playing") return;

        const now = performance.now();
        if (now - lastUpdateTime < PLAYER_UPDATE_INTERVAL) return;
        lastUpdateTime = now;

        const playerState = {
          x: player.x,
          y: player.y,
          angle: player.angle,
          name: player.name,
          score: score,
          shipId: player.shipId,
          timestamp: Date.now(),
        };

        try {
          if (!playerDocRef) {
            // Create the document reference if it doesn't exist (first run)
            const livePlayersCol = getLivePlayersCollection();
            playerDocRef = doc(livePlayersCol, player.uid);
            setDoc(playerDocRef, playerState); // Use setDoc to create with known ID
          } else {
            // Update the existing document
            updateDoc(playerDocRef, playerState);
          }
        } catch (e) {
          console.error("Failed to update player status:", e);
        }
      }

      function removePlayerStatus() {
        if (playerDocRef) {
          deleteDoc(playerDocRef)
            .then(() => {
              console.log("Player status removed from lobby.");
              playerDocRef = null;
            })
            .catch((e) => {
              console.error("Failed to remove player status:", e);
            });
        }
      }

      // --- LEADERBOARD LOGIC ---
      let leaderboardData = [];
      function setupLeaderboardListener() {
        if (!db) return;
        const leaderboardPath = `artifacts/${appId}/public/data/leaderboard`;
        const leaderboardCol = collection(db, leaderboardPath);

        const q = query(leaderboardCol, orderBy("score", "desc"), limit(20));

        onSnapshot(
          q,
          (snapshot) => {
            leaderboardData = [];
            snapshot.forEach((doc) => {
              leaderboardData.push(doc.data());
            });
            updateLeaderboardUI();
          },
          (error) => {
            console.error("Error listening to leaderboard:", error);
          }
        );
      }

      function updateLeaderboardUI() {
        const list = document.getElementById("leaderboard-list");
        list.innerHTML = "";
        leaderboardData.slice(0, 20).forEach((entry, index) => {
          const li = document.createElement("li");
          li.innerHTML = `<span>${index + 1}. ${entry.name}</span><span>${
            entry.score
          }</span>`;
          list.appendChild(li);
        });
      }

      async function saveScore(name, scoreToSave) {
        if (!name || scoreToSave <= 0 || !db) return;

        const leaderboardPath = `artifacts/${appId}/public/data/leaderboard`;
        const leaderboardCol = collection(db, leaderboardPath);

        // NEW: Check if the exact score already exists for this pilot
        try {
          const q = query(
            leaderboardCol,
            where("name", "==", name),
            where("score", "==", scoreToSave)
          );

          const existingDocs = await getDocs(q);
          if (existingDocs.size > 0) {
            console.warn(
              `Pilot ${name} already saved score ${scoreToSave}. Skipping.`
            );
            return;
          }

          await addDoc(leaderboardCol, {
            name: name,
            score: scoreToSave,
            timestamp: new Date(),
          });
          console.log("Score saved successfully! Current score retained.");
        } catch (error) {
          console.error("Error saving score: ", error);
        }
      }

      // NEW: Pilot Rank Definitions
      const PILOT_RANKS = [
        { score: 35001, name: "Galactic Overlord" },
        { score: 25001, name: "Super Invader" },
        { score: 17001, name: "Cosmic Invader" },
        { score: 10001, name: "Astro Scout" },
        { score: 5001, name: "Novice Explorer" },
        { score: 0, name: "Rookie Pilot" },
      ];
      let lastAchievedRankScore = 0; // Tracks the threshold of the current rank
      let basePirateSpeedMultiplier = 1.0; // Starts at 1.0

      // Utility function to get the current rank name
      function getCurrentRank(currentScore) {
        for (const rank of PILOT_RANKS) {
          if (currentScore >= rank.score) {
            return rank;
          }
        }
        return PILOT_RANKS[PILOT_RANKS.length - 1]; // Rookie Pilot
      }

      // Function to check for rank up and notify
      function checkRankUp() {
        const currentRank = getCurrentRank(score);
        if (currentRank.score > lastAchievedRankScore) {
          // If a rank is skipped (e.g., jump from 4000 to 12000),
          // we calculate the new multiplier based on the number of skipped ranks.
          const oldRankIndex = PILOT_RANKS.findIndex(
            (r) => r.score === lastAchievedRankScore
          );
          const newRankIndex = PILOT_RANKS.findIndex(
            (r) => r.score === currentRank.score
          );
          const ranksGained = oldRankIndex - newRankIndex;

          if (ranksGained > 0) {
            basePirateSpeedMultiplier *= Math.pow(1.2, ranksGained);
            console.log(
              `Ranks gained: ${ranksGained}. New Multiplier: ${basePirateSpeedMultiplier.toFixed(
                2
              )}`
            );
          }

          lastAchievedRankScore = currentRank.score;
          showRankNotification(currentRank.name);
        }
      }

      function showRankNotification(rankName) {
        newRankNameSpan.textContent = rankName;
        rankNotificationPanel.style.display = "block";

        // Hide after 3 seconds
        setTimeout(() => {
          rankNotificationPanel.style.display = "none";
        }, 3000);
      }

      // NEW: Function to show the mysterious intro message
      function showIntroMessage() {
        introMessagePanel.style.display = "block";
        setTimeout(() => {
          introMessagePanel.style.display = "none";
        }, 6000); // Display for 6 seconds
      }

      const mineralsDB = [
        {
          name: "Quartz",
          formula: "SiO₂",
          description: "A hard, crystalline mineral composed of silica.",
          rarity: "Common",
          score: 10,
        },
        {
          name: "Iron",
          formula: "Fe",
          description:
            "The most common element on Earth by mass, forged in the cores of stars.",
          rarity: "Common",
          score: 25,
        },
        {
          name: "Gold",
          formula: "Au",
          description:
            "A precious metal forged in the collision of neutron stars.",
          rarity: "Rare",
          score: 50,
        },
        {
          name: "Diamond",
          formula: "C",
          description:
            "A metastable allotrope of carbon, formed under immense pressure deep within planetary mantles.",
          rarity: "Rare",
          score: 80,
        },
        {
          name: "Iridium",
          formula: "Ir",
          description:
            "A very hard, brittle, silvery-white transition metal. Evidence of extraterrestrial impacts.",
          rarity: "Rare",
          score: 100,
        },
        {
          name: "Tanzanite",
          formula: "Ca₂Al₃(SiO₄)(Si₂O₇)O(OH)",
          description:
            "Exhibits strong trichroism, appearing alternately blue, violet and burgundy.",
          rarity: "Legendary",
          score: 225,
        },
        {
          name: "Painite",
          formula: "CaZrAl₉O₁₅(BO₃)",
          description:
            "Once held the Guinness World Record for the rarest gemstone.",
          rarity: "Legendary",
          score: 250,
        },
        {
          name: "Jarosite",
          formula: "KFe₃(SO₄)₂(OH)₆",
          description:
            "Its discovery on Mars provided strong evidence of past water activity.",
          rarity: "Unique",
          score: 1000,
        },
        {
          name: "Helium-3",
          formula: "³He",
          description:
            "A light, non-radioactive isotope of helium, thought to be abundant on the Moon.",
          rarity: "Unique",
          score: 1500,
        },
        {
          name: "Oganesson",
          formula: "Og",
          description:
            "The heaviest element ever created, with an extremely short half-life.",
          rarity: "Unique",
          score: 5000,
        },
      ];

      const shipImages = {
        ship1: new Image(),
        ship2: new Image(),
        ship3: new Image(),
      };
      const pirateImage = new Image();
      const stationImage = new Image();
      const superInvaderImages = [];
      const asteroidImages = [];
      const planetSpriteSheets = [];
      const PLANET_FRAME_COUNT = 24;
      const planetSpriteSheetSources = [
        "Planet_Sprite_Sheets/1.png",
        "Planet_Sprite_Sheets/2.png",
        "Planet_Sprite_Sheets/3.png",
        "Planet_Sprite_Sheets/4.png",
        "Planet_Sprite_Sheets/5.png",
        "Planet_Sprite_Sheets/6.png",
        "Planet_Sprite_Sheets/7.png",
        "Planet_Sprite_Sheets/8.png",
      ];
      const asteroidImageSources = [
        "Asteroids/1.png",
        "Asteroids/2.png",
        "Asteroids/3.png",
        "Asteroids/4.png",
        "Asteroids/5.png",
        "Asteroids/6.png",
        "Asteroids/7.png",
        "Asteroids/8.png",
        "Asteroids/9.png",
        "Asteroids/10.png",
        "Asteroids/11.png",
        "Asteroids/12.png",
        "Asteroids/13.png",
        "Asteroids/14.png",
        "Asteroids/15.png",
      ];
      const superInvaderImageSources = [
        "Superinvaders/inv1.png",
        "Superinvaders/inv2.png",
        "Superinvaders/inv3.png",
        "Superinvaders/inv4.png",
        "Superinvaders/inv5.png",
        "Superinvaders/inv6.png",
        "Superinvaders/inv7.png",
        "Superinvaders/inv8.png",
        "Superinvaders/inv9.png",
      ];

      const radarAudio = new Audio("Radar.mp3");
      const loopAudio = new Audio("loop.mp3");
      const alarmAudio = new Audio("alarm.mp3");
      const supAudio = new Audio("Sup.mp3");
      const shootAudio = new Audio("shoot.mp3"); // NEW: Shoot audio

      let assetsToLoad =
        planetSpriteSheetSources.length +
        asteroidImageSources.length +
        Object.keys(shipImages).length +
        2 +
        superInvaderImageSources.length +
        1; // UPDATED: Include new audio asset
      let assetsLoaded = 0;

      function assetLoaded() {
        assetsLoaded++;
        if (assetsLoaded === assetsToLoad) {
          startButton.disabled = false;
          startButton.textContent = "Start";
        }
      }

      let gameState = "menu";
      let score = 0;
      let nearestPlanetInfo = {
        name: "",
        distance: Infinity,
        discovered: false,
      };
      let isRadarPlaying = false;
      let isPanelOpen = false;
      let animationFrameId;
      let pendingInvasionRarity = null;
      let stealProgress = 0;
      let station = null;
      let nearestStationInfo = { distance: Infinity };

      const player = {
        x: 0,
        y: 0,
        radius: 15,
        angle: 0,
        rotationSpeed: 0.1,
        speed: 0,
        acceleration: 0.1,
        turboAcceleration: 0.5,
        friction: 0.98,
        image: null,
        velX: 0,
        velY: 0,
        name: "Pilot",
        shipId: null,
        fireRate: 15, // Shots per second, higher number is slower rate.
        fireTimer: 0,
      };

      const PROJECTILE_SPEED = 30; // UPDATED: Increased speed
      const PROJECTILE_RADIUS = 3;
      const PROJECTILE_DAMAGE = 1;
      let projectiles = []; // NEW: Array to hold active projectiles

      const REPULSION_RANGE = 150;
      const REPULSION_STRENGTH = 0.5;

      let pirates = [];
      const PIRATE_STEAL_RANGE = 300;
      const PIRATE_INVASION_DURATION = 25 * 60;

      const INITIAL_PIRATE_BASE_MAX_SPEED = 8.0;
      const INITIAL_PIRATE_BASE_ACCELERATION = 0.15;
      const INITIAL_PIRATE_TURBO_MAX_SPEED = 12.0;
      const INITIAL_PIRATE_TURBO_ACCELERATION = 0.2;

      let superInvaders = [];

      const camera = { x: player.x, y: player.y };
      let stars = [];
      const starLayers = [
        { speed: 0.2, radius: 0.5, countMultiplier: 0.5 },
        { speed: 0.4, radius: 1.0, countMultiplier: 0.35 },
        { speed: 0.6, radius: 1.2, countMultiplier: 0.15 },
      ];
      let planets = [];
      let asteroids = [];
      const SECTOR_SIZE = 5000;
      let generatedSectors = new Set();

      function mulberry32(a) {
        return function () {
          var t = (a += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      function generateEntitiesForSector(sectorX, sectorY) {
        const sectorKey = `${sectorX},${sectorY}`;
        if (generatedSectors.has(sectorKey)) return;
        generatedSectors.add(sectorKey);

        const seed = sectorX * 18397 + sectorY * 23117;
        const rng = mulberry32(seed);

        let hasPlanet = false;
        if (rng() < 0.25) {
          hasPlanet = true;
          const pScale = 3.0,
            pSheet =
              planetSpriteSheets[Math.floor(rng() * planetSpriteSheets.length)],
            frameWidth = pSheet.width / PLANET_FRAME_COUNT,
            w = frameWidth * pScale,
            h = pSheet.height * pScale,
            mineral = mineralsDB[Math.floor(rng() * mineralsDB.length)];
          planets.push({
            x: sectorX * SECTOR_SIZE + rng() * SECTOR_SIZE,
            y: sectorY * SECTOR_SIZE + rng() * SECTOR_SIZE,
            radius: w / 2,
            sheet: pSheet,
            discovered: false,
            width: w,
            height: h,
            frameCount: PLANET_FRAME_COUNT,
            frameWidth: frameWidth,
            currentFrame: 0,
            animationTimer: 0,
            animationSpeed: 20 + rng() * 15,
            mineral: mineral,
          });
        }

        if (rng() < 0.4) {
          const numAsteroids = Math.floor(rng() * 25) + 10;
          for (let i = 0; i < numAsteroids; i++) {
            const aImg =
              asteroidImages[Math.floor(rng() * asteroidImages.length)];
            asteroids.push({
              x: sectorX * SECTOR_SIZE + rng() * SECTOR_SIZE,
              y: sectorY * SECTOR_SIZE + rng() * SECTOR_SIZE,
              image: aImg,
              radius: aImg.width / 2,
              angle: rng() * Math.PI * 2,
              rotationSpeed: (rng() - 0.5) * 0.02,
              speedX: (rng() - 0.5) * 2,
              speedY: (rng() - 0.5) * 2,
            });
          }
        }

        if (!hasPlanet && !station && rng() < 0.03) {
          station = {
            x: sectorX * SECTOR_SIZE + rng() * SECTOR_SIZE,
            y: sectorY * SECTOR_SIZE + rng() * SECTOR_SIZE,
            radius: 100,
            image: stationImage,
          };
        }
      }

      function spawnPirate() {
        const spawnAngle = Math.random() * Math.PI * 2;
        const spawnDist = Math.max(canvas.width, canvas.height);
        pirates.push({
          x: player.x + Math.cos(spawnAngle) * spawnDist,
          y: player.y + Math.sin(spawnAngle) * spawnDist,
          radius: 20,
          angle: 0,
          rotationSpeed: 0.07,
          speed: 0,
          state: "chasing",
          timer: PIRATE_INVASION_DURATION,
          hp: 5, // NEW: Pirate Health
        });
        alarmAudio.play().catch((e) => console.warn("Alarm could not play"));
        pirateWarning.style.display = "block";
        invasionTimer.style.display = "block";
      }

      function updatePirates() {
        if (pirates.length === 0) return;

        let isPlayerBeingStolenFrom = false;

        // Calculate current maximum speeds based on rank multiplier
        const PIRATE_BASE_MAX_SPEED =
          INITIAL_PIRATE_BASE_MAX_SPEED * basePirateSpeedMultiplier;
        const PIRATE_TURBO_MAX_SPEED =
          INITIAL_PIRATE_TURBO_MAX_SPEED * basePirateSpeedMultiplier;

        const PIRATE_BASE_ACCELERATION =
          INITIAL_PIRATE_BASE_ACCELERATION * basePirateSpeedMultiplier;
        const PIRATE_TURBO_ACCELERATION =
          INITIAL_PIRATE_TURBO_ACCELERATION * basePirateSpeedMultiplier;

        const firstPirate = pirates[0];
        const timeLeft = Math.ceil(firstPirate.timer / 60);
        invasionTimer.textContent = `${timeLeft}s`;

        for (let i = pirates.length - 1; i >= 0; i--) {
          const pirate = pirates[i];
          pirate.timer--;

          if (pirate.state === "chasing") {
            if (pirate.timer <= 0) {
              pirate.state = "escaping";
            }

            const predictionTime = 30 + player.speed * 2;
            const predictedPlayerX = player.x + player.velX * predictionTime;
            const predictedPlayerY = player.y + player.velY * predictionTime;

            const dx = predictedPlayerX - pirate.x;
            const dy = predictedPlayerY - pirate.y;
            const targetAngle = Math.atan2(dy, dx);

            let angleDiff = targetAngle - pirate.angle;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            pirate.angle += angleDiff * pirate.rotationSpeed;
            pirate.angle %= Math.PI * 2;

            const targetMaxSpeed = keys.Shift
              ? PIRATE_TURBO_MAX_SPEED
              : PIRATE_BASE_MAX_SPEED;
            const targetAcceleration = keys.Shift
              ? PIRATE_TURBO_ACCELERATION
              : PIRATE_BASE_ACCELERATION;
            pirate.speed = Math.min(
              targetMaxSpeed,
              pirate.speed + targetAcceleration
            );

            const stealDist = Math.sqrt(
              Math.pow(player.x - pirate.x, 2) +
                Math.pow(player.y - pirate.y, 2)
            );
            if (stealDist < PIRATE_STEAL_RANGE) {
              isPlayerBeingStolenFrom = true;
            }
          } else if (pirate.state === "escaping") {
            pirate.speed += INITIAL_PIRATE_BASE_ACCELERATION; // Use base acceleration for escape
            if (pirate.timer < -300) {
              pirates.splice(i, 1);
            }
          }

          if (pirate) {
            pirate.x += pirate.speed * Math.cos(pirate.angle);
            pirate.y += pirate.speed * Math.sin(pirate.angle);
          }
        }

        if (isPlayerBeingStolenFrom) {
          stealProgress = Math.min(100, stealProgress + 0.5);
          stealBarContainer.style.display = "block";
          stealBar.style.width = `${stealProgress}%`;
        } else {
          stealProgress = Math.max(0, stealProgress - 0.1);
          if (stealProgress > 0) {
            stealBar.style.width = `${stealProgress}%`;
          } else {
            stealBarContainer.style.display = "none";
          }
        }

        if (stealProgress >= 100) {
          score = 0;
          pirates.forEach((p) => (p.state = "escaping"));
        }

        if (pirates.length === 0) {
          pirateWarning.style.display = "none";
          stealBarContainer.style.display = "none";
          invasionTimer.style.display = "none";
        }
      }

      function spawnSuperInvader() {
        if (superInvaders.length > 0) return;

        supAudio
          .play()
          .catch((e) => console.warn("Super invader sound failed to play"));

        const edge = Math.floor(Math.random() * 4);
        let startX, startY, endX, endY;
        const buffer = 100;

        if (edge === 0) {
          startX = Math.random() * canvas.width;
          startY = -buffer;
          endX = Math.random() * canvas.width;
          endY = canvas.height + buffer;
        } else if (edge === 1) {
          startX = canvas.width + buffer;
          startY = Math.random() * canvas.height;
          endX = -buffer;
          endY = Math.random() * canvas.height;
        } else {
          startX = -buffer;
          startY = Math.random() * canvas.height;
          endX = canvas.width + buffer;
          endY = Math.random() * canvas.height;
        }

        const angle = Math.atan2(endY - startY, endX - startX);
        const namePrefixes = ["X", "Z", "V", "R", "T"];
        const name = `${
          namePrefixes[Math.floor(Math.random() * namePrefixes.length)]
        }${Math.floor(Math.random() * 9) + 1} Super Invader`;

        superInvaders.push({
          x: startX + camera.x,
          y: startY + camera.y,
          angle: angle,
          speed: (15 + Math.random() * 5) * 1.5,
          image:
            superInvaderImages[
              Math.floor(Math.random() * superInvaderImages.length)
            ],
          name: name,
          hp: 10, // NEW: Super Invader Health
        });
      }

      function updateSuperInvaders() {
        for (let i = superInvaders.length - 1; i >= 0; i--) {
          const invader = superInvaders[i];
          invader.x += invader.speed * Math.cos(invader.angle);
          invader.y += invader.speed * Math.sin(invader.angle);

          const screenX = invader.x - camera.x;
          const screenY = invader.y - camera.y;
          const buffer = 200;

          if (
            screenX < -buffer ||
            screenX > canvas.width + buffer ||
            screenY < -buffer ||
            screenY > canvas.height + buffer
          ) {
            superInvaders.splice(i, 1);
          }
        }
      }

      // NEW: Firing a Projectile
      function shoot() {
        if (player.fireTimer <= 0) {
          projectiles.push({
            x: player.x,
            y: player.y,
            radius: PROJECTILE_RADIUS,
            angle: player.angle,
            speed: PROJECTILE_SPEED,
            damage: PROJECTILE_DAMAGE,
            velX: PROJECTILE_SPEED * Math.cos(player.angle),
            velY: PROJECTILE_SPEED * Math.sin(player.angle),
          });
          player.fireTimer = player.fireRate; // Reset fire timer

          // Play shoot sound effect
          shootAudio.currentTime = 0;
          shootAudio
            .play()
            .catch((e) => console.warn("Shoot audio failed to play:", e));
        }
      }

      // NEW: Check collisions between projectiles and enemies
      function checkProjectileCollisions() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          let hit = false;

          // Check Pirates
          for (let j = pirates.length - 1; j >= 0; j--) {
            const enemy = pirates[j];
            const distSq =
              Math.pow(p.x - enemy.x, 2) + Math.pow(p.y - enemy.y, 2);
            const radiusSumSq = Math.pow(p.radius + enemy.radius, 2);

            if (distSq < radiusSumSq) {
              applyDamage(enemy, p.damage);
              hit = true;
              break;
            }
          }

          // Check Super Invaders
          if (!hit) {
            for (let j = superInvaders.length - 1; j >= 0; j--) {
              const enemy = superInvaders[j];
              const distSq =
                Math.pow(p.x - enemy.x, 2) + Math.pow(p.y - enemy.y, 2);
              const radiusSumSq = Math.pow(p.radius + 20, 2); // Approximation for SI radius

              if (distSq < radiusSumSq) {
                applyDamage(enemy, p.damage);
                hit = true;
                break;
              }
            }
          }

          // NEW: Check Live Opponents (Multiplayer)
          if (!hit) {
            for (let k = livePlayers.length - 1; k >= 0; k--) {
              const opponent = livePlayers[k];
              const distSq =
                Math.pow(p.x - opponent.x, 2) + Math.pow(p.y - opponent.y, 2);
              const radiusSumSq = Math.pow(p.radius + 15, 2); // Player ship radius is 15

              if (distSq < radiusSumSq) {
                // Simple solution: Remove opponent from lobby when hit
                deleteDoc(
                  doc(
                    db,
                    `artifacts/${appId}/public/data/live_players/${opponent.id}`
                  )
                );
                score += 500; // Reward for player kill
                hit = true;
                break;
              }
            }
          }

          if (hit) {
            projectiles.splice(i, 1); // Remove projectile on hit
          }
        }
      }

      // NEW: Apply damage and check for destruction
      function applyDamage(enemy, damage) {
        enemy.hp -= damage;
        if (enemy.hp <= 0) {
          destroyEnemy(enemy);
        }
      }

      // NEW: Destroy enemy and update score
      function destroyEnemy(enemy) {
        if (pirates.includes(enemy)) {
          score += 50; // Points for pirates
          pirates.splice(pirates.indexOf(enemy), 1);
        } else if (superInvaders.includes(enemy)) {
          score += 200; // Points for super invaders
          superInvaders.splice(superInvaders.indexOf(enemy), 1);
        }
      }

      // REVERTED to 4-way arrow key controls for rotational movement
      const keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        " ": false, // Space is only used for keydown event (shooting)
        e: false,
      };

      let touchMoving = false;

      const KEYBOARD_CONTROLS = [
        "ArrowUp",
        "ArrowDown",
        "ArrowLeft",
        "ArrowRight",
        " ",
        "e",
        "E",
      ];
      const MOVEMENT_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]; // Removed Shift

      window.addEventListener("keydown", (e) => {
        const key = e.key;

        // Convert to lowercase for consistent checking against the keys object
        const lowerKey = key.toLowerCase();

        if (
          KEYBOARD_CONTROLS.includes(key) ||
          KEYBOARD_CONTROLS.includes(lowerKey)
        ) {
          // Prevent default for movement keys (for screen scroll) and shooting/interaction
          if (
            MOVEMENT_KEYS.includes(key) ||
            MOVEMENT_KEYS.includes(lowerKey) ||
            key === " " ||
            key === "e" ||
            key === "E"
          ) {
            e.preventDefault();
          }

          // Only set key state if it's not the Spacebar
          if (key !== " ") {
            keys[key] = true;
          }
        }

        // Handle shooting on Spacebar (PC only, triggered once per keydown)
        if (key === " " && gameState === "playing" && !isPanelOpen) {
          shoot();
        }

        // Handle interaction on E
        if (key === "e" || key === "E") {
          if (isPanelOpen) {
            toggleDiscoveryPanel(false);
          } else if (isNearStation()) {
            dockAtStation();
          }
        }
      });

      window.addEventListener("keyup", (e) => {
        const key = e.key;
        if (
          KEYBOARD_CONTROLS.includes(key) ||
          KEYBOARD_CONTROLS.includes(key.toLowerCase())
        ) {
          // If it's a directional key, release the state.
          if (key !== " ") {
            keys[key] = false;
          }
        }
      });

      startButton.addEventListener("click", () => {
        loopAudio.play().catch(() => {});
        loopAudio.pause();
        alarmAudio.play().catch(() => {});
        alarmAudio.pause();
        radarAudio.play().catch(() => {});
        radarAudio.pause();
        supAudio.play().catch(() => {});
        supAudio.pause();
        shootAudio.pause(); // NEW: Pause shoot audio

        mainMenuScreen.style.display = "none";
        shipSelectScreen.style.display = "flex";
        gameState = "shipSelect";
      });
      restartButton.addEventListener("click", () => {
        gameOverScreen.style.display = "none";
        mainMenuScreen.style.display = "flex";
        gameState = "menu";
        loopAudio.pause();
        loopAudio.currentTime = 0;
      });

      // NEW: Pilot Name input listener
      pilotNameInput.addEventListener("input", () => {
        confirmPilotNameButton.disabled =
          pilotNameInput.value.trim().length === 0;
      });

      // NEW: Confirm Pilot Name logic
      confirmPilotNameButton.addEventListener("click", () => {
        const name = pilotNameInput.value.trim();
        if (name) {
          player.name = name;
          pilotNameScreen.style.display = "none";
          startGame(player.shipId); // Start game with saved shipId
        }
      });

      shipCards.forEach((card) => {
        if (card.classList.contains("locked")) return;
        card.addEventListener("click", () => {
          player.shipId = card.getAttribute("data-ship"); // Save ship ID
          shipSelectScreen.style.display = "none";
          pilotNameScreen.style.display = "flex"; // Go to name input screen
          gameState = "nameInput"; // Set new state
        });
      });

      discoveryPanel.addEventListener("click", () =>
        toggleDiscoveryPanel(false)
      );

      leaderboardButton.addEventListener(
        "click",
        () => (leaderboardModal.style.display = "flex")
      );
      closeLeaderboardButton.addEventListener(
        "click",
        () => (leaderboardModal.style.display = "none")
      );
      undockButton.addEventListener("click", undock);
      viewLeaderboardFromStationButton.addEventListener(
        "click",
        () => (leaderboardModal.style.display = "flex")
      );
      saveScoreButton.addEventListener("click", () => {
        const playerName = document
          .getElementById("playerNameInput")
          .value.trim();
        // Use the actual player name for saving, fall back to input if needed
        const nameToSave = playerName || player.name || "Anon";
        if (nameToSave) {
          saveScore(nameToSave, score);
          document.getElementById("playerNameInput").value = player.name; // Keep player name in input field
          undock();
        } else {
          document.getElementById("playerNameInput").style.borderColor = "red";
        }
      });
      dockButton.addEventListener("click", dockAtStation);

      function startGame(shipId) {
        player.image = shipImages[shipId];
        // The display logic is now handled by the name input screen
        canvas.style.display = "block";

        resetGameData();
        // Initial rank check to set lastAchievedRankScore
        lastAchievedRankScore = getCurrentRank(score).score;

        gameState = "playing";
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        loopAudio.loop = true;
        loopAudio.volume = 0.4;
        loopAudio
          .play()
          .catch((e) => console.warn("Background audio auto-play failed."));

        showIntroMessage(); // NEW: Display mysterious message
        gameLoop();
      }

      function resetGameData() {
        player.x = 0;
        player.y = 0;
        player.speed = 0;
        player.angle = 0;
        player.velX = 0;
        player.velY = 0;
        camera.x = 0;
        camera.y = 0;
        player.fireTimer = 0; // NEW: Reset fire timer

        removePlayerStatus(); // NEW: Remove player from live lobby on game reset

        projectiles = []; // NEW: Reset projectiles array
        planets = [];
        asteroids = [];
        superInvaders = [];
        generatedSectors.clear();
        score = 0; // Score only resets upon starting a new game
        basePirateSpeedMultiplier = 1.0; // Reset pirate difficulty
        lastAchievedRankScore = 0;
        pirates = [];
        station = null;
        stealProgress = 0;
        pirateWarning.style.display = "none";
        invasionTimer.style.display = "none";
        stealBarContainer.style.display = "none";
        toggleDiscoveryPanel(false);
      }

      function toggleDiscoveryPanel(show, mineral = null) {
        if (show && mineral) {
          isPanelOpen = true;
          discoveryPanel.style.display = "block";
          document.getElementById(
            "discovery-name"
          ).textContent = `[${mineral.rarity}] ${mineral.name}`;
          document.getElementById(
            "discovery-name"
          ).className = `rarity-${mineral.rarity}`;
          document.getElementById(
            "discovery-formula"
          ).textContent = `Formula: ${mineral.formula}`;
          document.getElementById("discovery-description").textContent =
            mineral.description;
        } else {
          if (isPanelOpen) {
            isPanelOpen = false;
            discoveryPanel.style.display = "none";
            triggerPendingInvasion();
          }
        }
      }

      function triggerPendingInvasion() {
        if (!pendingInvasionRarity) return;

        const rarity = pendingInvasionRarity;
        pendingInvasionRarity = null;
        const rarityRoll = Math.random();

        if (rarity === "Unique") {
          spawnPirate();
          spawnPirate();
        } else if (
          (rarity === "Legendary" && rarityRoll < 0.75) ||
          (rarity === "Rare" && rarityRoll < 0.25)
        ) {
          spawnPirate();
        }
      }

      const DOCKING_RANGE = 200;

      function isNearStation() {
        return station && nearestStationInfo.distance < DOCKING_RANGE;
      }

      function dockAtStation() {
        if (!isNearStation()) return;
        gameState = "docked";
        document.getElementById("save-score-value").textContent = score;
        document.getElementById("playerNameInput").value = player.name; // Pre-fill name
        saveScoreModal.style.display = "flex";
      }

      function undock() {
        saveScoreModal.style.display = "none";
        gameState = "playing";
      }

      function generateStars() {
        stars = [];
        const base = (canvas.width * canvas.height) / 3000;
        starLayers.forEach((l) => {
          for (let i = 0; i < Math.floor(base * l.countMultiplier); i++)
            stars.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              radius: l.radius,
              speed: l.speed,
            });
        });
      }
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        generateStars();
      }
      window.addEventListener("resize", resizeCanvas);

      function gameLoop() {
        if (gameState === "docked" || gameState === "nameInput") {
          requestAnimationFrame(gameLoop);
          return;
        }

        if (gameState === "playing" && !isPanelOpen) {
          // NEW: Decrement fire timer
          if (player.fireTimer > 0) {
            player.fireTimer--;
          }

          // NEW: Update live player status to Firestore
          updatePlayerStatus();

          // Check for rank up every frame based on current score
          checkRankUp();

          // UPDATED: Calculate max player speed based on PROJECTILE_SPEED
          const MAX_PLAYER_SPEED = PROJECTILE_SPEED * 0.9;

          // Determine acceleration
          // TURBO IS ALWAYS ACTIVE
          let accel = player.turboAcceleration;
          let maxSpeed = MAX_PLAYER_SPEED;

          // 1. Rotation (Left/Right)
          if (keys.ArrowLeft) player.angle -= player.rotationSpeed;
          if (keys.ArrowRight) player.angle += player.rotationSpeed;

          // 2. Thrust Forward/Reverse (Up/Down)
          if (keys.ArrowUp || touchMoving) {
            // Apply acceleration, capped by max speed
            player.speed = Math.min(maxSpeed, player.speed + accel);
          } else if (keys.ArrowDown) {
            // Apply reverse thrust/deceleration
            player.speed -= accel * 0.5;
          }

          // Friction/Velocity Update
          player.speed *= player.friction;

          // Clamp speed to prevent reverse speed from going too far back
          player.speed = Math.max(-10, Math.min(player.speed, maxSpeed));

          player.velX = player.speed * Math.cos(player.angle);
          player.velY = player.speed * Math.sin(player.angle);
          player.x += player.velX;
          player.y += player.velY;

          // NEW: Update projectiles position
          for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.x += p.velX;
            p.y += p.velY;

            // Remove projectiles that go off-screen (simplistic)
            const screenX = p.x - camera.x + canvas.width / 2;
            const screenY = p.y - camera.y + canvas.height / 2;
            if (
              screenX < -200 ||
              screenX > canvas.width + 200 ||
              screenY < -200 ||
              screenY > canvas.height + 200
            ) {
              projectiles.splice(i, 1);
            }
          }

          // NEW: Check collisions after all movement
          checkProjectileCollisions();
        }
        if (gameState === "playing") {
          camera.x = player.x;
          camera.y = player.y;

          const sX = Math.floor(player.x / SECTOR_SIZE),
            sY = Math.floor(player.y / SECTOR_SIZE);
          for (let y = -1; y <= 1; y++) {
            for (let x = -1; x <= 1; x++)
              generateEntitiesForSector(sX + x, sY + y);
          }

          updatePirates();
          updateSuperInvaders();

          if (Math.random() < 0.0002) {
            // UPDATED: Reduced spawn rate
            spawnSuperInvader();
          }

          asteroids.forEach((a) => {
            a.x += a.speedX;
            a.y += a.speedY;
            a.angle += a.rotationSpeed;
            const dx = a.x - player.x,
              dy = a.y - player.y,
              dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < REPULSION_RANGE) {
              const forceAngle = Math.atan2(dy, dx),
                forceMagnitude =
                  REPULSION_STRENGTH * (1 - dist / REPULSION_RANGE);
              a.speedX += Math.cos(forceAngle) * forceMagnitude;
              a.speedY += Math.sin(forceAngle) * forceMagnitude;
            }
          });

          planets.forEach((p) => {
            p.animationTimer++;
            if (p.animationTimer > p.animationSpeed) {
              p.animationTimer = 0;
              p.currentFrame = (p.currentFrame + 1) % p.frameCount;
            }
          });

          if (station) {
            const dx = player.x - station.x;
            const dy = player.y - station.y;
            nearestStationInfo.distance = Math.sqrt(dx * dx + dy * dy);

            if (isNearStation()) {
              dockPrompt.style.display = "block";
              dockButton.style.display = "flex";
            } else {
              dockPrompt.style.display = "none";
              dockButton.style.display = "none";
            }
          } else {
            nearestStationInfo.distance = Infinity;
            dockPrompt.style.display = "none";
            dockButton.style.display = "none";
          }
        }

        ctx.save();
        let invaderShake = superInvaders.length > 0;
        if ((gameState === "playing" && player.speed > 5) || invaderShake) {
          const shake = invaderShake ? 2 : player.speed * 0.2;
          ctx.translate(
            (Math.random() - 0.5) * shake,
            (Math.random() - 0.5) * shake
          );
        }
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        stars.forEach((s) => {
          const pX =
            (((s.x - camera.x * s.speed) % canvas.width) + canvas.width) %
            canvas.width;
          const pY =
            (((s.y - camera.y * s.speed) % canvas.height) + canvas.height) %
            canvas.height;
          if (player.speed > 2) {
            const len = player.speed * s.speed * 0.6,
              sX = pX - Math.cos(player.angle) * len,
              sY = pY - Math.sin(player.angle) * len;
            ctx.beginPath();
            ctx.moveTo(sX, sY);
            ctx.lineTo(pX, pY);
            ctx.strokeStyle = "#FFF";
            ctx.lineWidth = s.radius * 2;
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(pX, pY, s.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#FFF";
            ctx.fill();
          }
        });

        let minDistance = Infinity;
        let currentNearestPlanet = null;
        planets.forEach((p) => {
          const psX = p.x - camera.x + canvas.width / 2,
            psY = p.y - camera.y + canvas.height / 2;
          if (
            psX + p.radius > 0 &&
            psX - p.radius < canvas.width &&
            psY + p.radius > 0 &&
            psY - p.radius < canvas.height
          ) {
            const sourceX = p.currentFrame * p.frameWidth;
            ctx.drawImage(
              p.sheet,
              sourceX,
              0,
              p.frameWidth,
              p.sheet.height,
              psX - p.radius,
              psY - p.radius,
              p.width,
              p.height
            );
          }
          if (gameState === "playing") {
            const dx = player.x - p.x,
              dy = player.y - p.y,
              dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDistance) {
              minDistance = dist;
              currentNearestPlanet = p;
            }
            if (dist < p.radius + 100 && !p.discovered) {
              p.discovered = true;
              score += p.mineral.score;
              toggleDiscoveryPanel(true, p.mineral);
              pendingInvasionRarity = p.mineral.rarity;
            }
          }
        });
        asteroids.forEach((a) => {
          const asX = a.x - camera.x + canvas.width / 2,
            asY = a.y - camera.y + canvas.height / 2;
          if (
            asX + a.radius > 0 &&
            asX - a.radius < canvas.width &&
            asY + a.radius > 0 &&
            asY - a.radius < canvas.height
          ) {
            ctx.save();
            ctx.translate(asX, asY);
            ctx.rotate(a.angle);
            ctx.drawImage(
              a.image,
              -a.radius,
              -a.radius,
              a.radius * 2,
              a.radius * 2
            );
            ctx.restore();
          }
        });

        if (station) {
          const sX = station.x - camera.x + canvas.width / 2;
          const sY = station.y - camera.y + canvas.height / 2;
          if (
            sX + station.radius > 0 &&
            sX - station.radius < canvas.width &&
            sY + station.radius > 0 &&
            sY - station.radius < canvas.height
          ) {
            ctx.drawImage(
              station.image,
              sX - station.radius,
              sY - station.radius,
              station.radius * 2,
              station.radius * 2
            );
          }
        }

        // NEW: Draw Live Opponents
        livePlayers.forEach((opponent) => {
          const opScreenX = opponent.x - camera.x + canvas.width / 2;
          const opScreenY = opponent.y - camera.y + canvas.height / 2;

          ctx.save();
          ctx.translate(opScreenX, opScreenY);
          ctx.rotate(opponent.angle + Math.PI / 2);

          // Draw opponent ship (using ship2 image for distinctiveness)
          ctx.drawImage(
            shipImages.ship2,
            -shipImages.ship2.width / 2,
            -shipImages.ship2.height / 2,
            shipImages.ship2.width,
            shipImages.ship2.height
          );

          ctx.restore();

          // Draw Opponent Name and Score
          ctx.font = '12px "Press Start 2P"';
          ctx.textAlign = "center";
          ctx.fillStyle = "#FFDD44"; // Yellow color for opponents
          ctx.fillText(opponent.name, opScreenX, opScreenY - 30);
          ctx.fillText(opponent.score, opScreenX, opScreenY + 40);
        });
        // END NEW: Draw Live Opponents

        pirates.forEach((pirate) => {
          const pScreenX = pirate.x - camera.x + canvas.width / 2;
          const pScreenY = pirate.y - camera.y + canvas.height / 2;

          if (pirate.state === "chasing") {
            ctx.beginPath();
            ctx.arc(pScreenX, pScreenY, PIRATE_STEAL_RANGE, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 0, 0, 0.1)";
            ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
          }

          ctx.save();
          ctx.translate(pScreenX, pScreenY);
          ctx.rotate(pirate.angle + Math.PI / 2);
          ctx.drawImage(
            pirateImage,
            -pirateImage.width / 2,
            -pirateImage.height / 2
          );
          ctx.restore();

          // Draw pirate health bar (simple red box)
          const barWidth = 40;
          const barHeight = 4;
          const healthRatio = pirate.hp / 5; // Pirates have 5 HP
          ctx.fillStyle = "red";
          ctx.fillRect(
            pScreenX - barWidth / 2,
            pScreenY + pirateImage.height / 2 + 5,
            barWidth * healthRatio,
            barHeight
          );
        });

        superInvaders.forEach((invader) => {
          const iScreenX = invader.x - camera.x;
          const iScreenY = invader.y - camera.y;

          ctx.save();
          ctx.translate(iScreenX, iScreenY);
          ctx.rotate(invader.angle + Math.PI / 2);
          ctx.drawImage(
            invader.image,
            -invader.image.width / 2,
            -invader.image.height / 2
          );
          ctx.restore();

          ctx.font = '12px "Press Start 2P"';
          ctx.textAlign = "center";
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#00ffff";
          ctx.fillText(invader.name, iScreenX, iScreenY - 40);
          ctx.shadowBlur = 0;

          // Draw Super Invader health bar (blue box)
          const barWidth = 60;
          const barHeight = 6;
          const healthRatio = invader.hp / 10; // SI have 10 HP
          ctx.fillStyle = "blue";
          ctx.fillRect(
            iScreenX - barWidth / 2,
            iScreenY + invader.image.height / 2 + 5,
            barWidth * healthRatio,
            barHeight
          );
        });

        // NEW: Draw Projectiles (Red)
        projectiles.forEach((p) => {
          const pScreenX = p.x - camera.x + canvas.width / 2;
          const pScreenY = p.y - camera.y + canvas.height / 2;

          ctx.beginPath();
          ctx.arc(pScreenX, pScreenY, p.radius, 0, Math.PI * 2);
          ctx.fillStyle = "#FF4444";
          ctx.shadowColor = "#FF0000";
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
        });

        if (currentNearestPlanet) {
          nearestPlanetInfo = {
            name: currentNearestPlanet.discovered
              ? currentNearestPlanet.mineral.name
              : "Unknown Planet",
            distance: minDistance,
            discovered: currentNearestPlanet.discovered,
          };
        }

        const RADAR_RANGE = 2000;
        if (
          gameState === "playing" &&
          !isPanelOpen &&
          currentNearestPlanet &&
          !currentNearestPlanet.discovered &&
          minDistance < RADAR_RANGE
        ) {
          if (!isRadarPlaying) {
            radarAudio.loop = true;
            radarAudio
              .play()
              .catch((e) => console.warn("Audio policy warning"));
            isRadarPlaying = true;
          }
        } else {
          if (isRadarPlaying) {
            radarAudio.pause();
            radarAudio.currentTime = 0;
            isRadarPlaying = false;
          }
        }

        if (gameState === "playing" && player.image) {
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.rotate(player.angle + Math.PI / 2);
          ctx.drawImage(
            player.image,
            -player.image.width / 2,
            -player.image.height / 2
          );
          ctx.restore();
        }

        if (gameState === "playing") {
          ctx.font = '16px "Press Start 2P"';
          ctx.fillStyle = "white";
          ctx.textAlign = "left";

          const currentRankName = getCurrentRank(score).name;

          ctx.fillText(`${player.name} (${currentRankName})`, 10, 30);
          ctx.fillText(`Score: ${score}`, 10, 60);

          if (nearestPlanetInfo.name) {
            ctx.fillStyle = nearestPlanetInfo.discovered
              ? "lightgreen"
              : "white";
            ctx.fillText(
              `${nearestPlanetInfo.name} - ${Math.round(
                nearestPlanetInfo.distance
              )}`,
              10,
              90
            );
          }
          if (station) {
            ctx.fillStyle = "#00ffff";
            ctx.fillText(
              `Station - ${Math.round(nearestStationInfo.distance)}`,
              10,
              120
            );
          }
        }

        ctx.restore();
        animationFrameId = requestAnimationFrame(gameLoop);
      }

      function setupTouchControls() {
        const isTouch =
          "ontouchstart" in window || navigator.maxTouchPoints > 0;
        if (!isTouch) return;

        touchControls.style.display = "block";

        const joystickBase = document.getElementById("joystick-base");
        const joystickKnob = document.getElementById("joystick-knob");
        // Removed turbo button reference
        const fireButton = document.getElementById("shoot-button");
        const dockButton = document.getElementById("dock-button"); // Keep dock button reference

        let joyStickActive = false;
        let joyStickId = null;

        const JOYSTICK_MAX_TRAVEL = 60; // Half of joystick base width/height

        joystickBase.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            if (joyStickActive) return;
            joyStickActive = true;
            joyStickId = e.changedTouches[0].identifier;
            touchMoving = true; // Start applying thrust immediately
          },
          { passive: false }
        );

        window.addEventListener(
          "touchmove",
          (e) => {
            if (!joyStickActive) return;
            e.preventDefault();
            for (let touch of e.changedTouches) {
              if (touch.identifier === joyStickId) {
                const rect = joystickBase.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;

                // FIX: Corrected rotation offset for mobile joystick
                // Reverting to the simplest intuitive approach: atan2(dy, dx) + PI/2
                // The issue is likely how the image is drawn vs the angle.
                player.angle = Math.atan2(dy, dx) + Math.PI / 2;

                // Debugging console log to check inputs
                console.log(
                  `Joystick: dx=${dx.toFixed(0)}, dy=${dy.toFixed(0)}, angle=${(
                    (player.angle * 180) /
                    Math.PI
                  ).toFixed(0)}`
                );

                // Clamp knob position
                const dist = Math.sqrt(dx * dx + dy * dy);
                const ratio =
                  dist > JOYSTICK_MAX_TRAVEL ? JOYSTICK_MAX_TRAVEL / dist : 1;

                const clampedX = dx * ratio;
                const clampedY = dy * ratio;

                // Move knob relative to center
                joystickKnob.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
              }
            }
          },
          { passive: false }
        );

        window.addEventListener("touchend", (e) => {
          for (let touch of e.changedTouches) {
            if (touch.identifier === joyStickId) {
              joyStickActive = false;
              joyStickId = null;
              touchMoving = false; // Stop applying thrust

              // Reset knob position
              joystickKnob.style.transform = `translate(0px, 0px)`;
            }
          }
        });

        const setupButton = (element, key) => {
          element.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              keys[key] = true;
              element.classList.add("active");

              // Handle shooting directly for the fire button
              if (element.id === "shoot-button") {
                shoot();
              }
            },
            { passive: false }
          );
          element.addEventListener("touchend", (e) => {
            e.preventDefault();
            keys[key] = false;
            element.classList.remove("active");
          });
        };

        // NOTE: Turbo button is removed (Logic is permanent)
        setupButton(fireButton, " ");
        setupButton(dockButton, "e");
      }

      function loadAllAssets() {
        resizeCanvas();

        const setupImageLoader = (img, src) => {
          img.onload = assetLoaded;
          img.onerror = () => {
            console.error(`Failed to load asset: ${src}`);
            assetLoaded(); // Call assetLoaded even on error to prevent blocking
          };
          img.src = src;
          assetCache.appendChild(img);
        };

        // --- ASSET LIST (Images) ---
        setupImageLoader(shipImages.ship1, "ship1.png");
        setupImageLoader(shipImages.ship2, "ship2.png");
        setupImageLoader(shipImages.ship3, "ship3.png");
        setupImageLoader(pirateImage, "Pirate.png");
        setupImageLoader(stationImage, "Station.png");

        asteroidImageSources.forEach((src) => {
          const i = new Image();
          asteroidImages.push(i);
          setupImageLoader(i, src);
        });

        planetSpriteSheetSources.forEach((src) => {
          const i = new Image();
          planetSpriteSheets.push(i);
          setupImageLoader(i, src);
        });

        superInvaderImageSources.forEach((src) => {
          const i = new Image();
          superInvaderImages.push(i);
          setupImageLoader(i, src);
        });

        // --- ASSET LIST (Audio - MUST BE LOADED SAFELY) ---
        // Audio loading is tricky; we call assetLoaded for audio files immediately
        // since Audio objects don't reliably fire onload events, and they rarely block.
        // The total count was adjusted to account for all audio files.
        assetLoaded(); // Radar.mp3
        assetLoaded(); // loop.mp3
        assetLoaded(); // alarm.mp3
        assetLoaded(); // Sup.mp3
        setupImageLoader(shootAudio, "shoot.mp3"); // Load shoot audio as an image to track load state

        setupTouchControls();
      }

      initFirebase();
      loadAllAssets();
    </script>
  </body>
</html>
